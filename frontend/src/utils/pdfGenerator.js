import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

export const generatePDFReport = (scanData) => {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;

    // --- Helper Styling Functions ---
    const colors = {
        primary: [15, 23, 42], // Slate 900
        accent: [14, 165, 233], // Sky 500
        high: [239, 68, 68], // Red 500
        medium: [245, 158, 11], // Amber 500
        low: [16, 185, 129], // Emerald 500
        text: [51, 65, 85], // Slate 700
        lightText: [100, 116, 139] // Slate 500
    };

    const addHeader = (y = 20) => {
        doc.setFillColor(...colors.primary);
        doc.rect(0, 0, pageWidth, 20, 'F');
        doc.setFontSize(10);
        doc.setTextColor(255, 255, 255);
        doc.text("CyberShield Security Assessment", 10, 13);
        doc.text(new Date().toLocaleString(), pageWidth - 10, 13, { align: 'right' });
    };

    const addFooter = (pageNo) => {
        doc.setFontSize(8);
        doc.setTextColor(...colors.lightText);
        doc.text(`Confidential - Generated by CyberShield AI - Page ${pageNo}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
    };

    // --- COVER PAGE ---
    // Background Header
    doc.setFillColor(...colors.primary);
    doc.rect(0, 0, pageWidth, 60, 'F');

    // Title
    doc.setFont("helvetica", "bold");
    doc.setFontSize(28);
    doc.setTextColor(255, 255, 255);
    doc.text("Security Assessment Report", 20, 30);
    doc.setFontSize(12);
    doc.setTextColor(200, 200, 200);
    doc.text("Comprehensive Vulnerability Analysis & Remediation Plan", 20, 40);

    // Target Info Box
    doc.setDrawColor(200, 200, 200);
    doc.setFillColor(255, 255, 255);
    doc.roundedRect(20, 50, pageWidth - 40, 25, 3, 3, 'F');
    doc.setFontSize(10);
    doc.setTextColor(...colors.lightText);
    doc.text("TARGET URL", 25, 60);
    doc.setFontSize(12);
    doc.setTextColor(...colors.primary);
    doc.text(scanData.url, 25, 68);

    // Risk Score Circle (Simplified Visual)
    const scoreColor = scanData.risk_score > 70 ? colors.low : scanData.risk_score > 40 ? colors.medium : colors.high;
    doc.setFillColor(...scoreColor);
    doc.circle(pageWidth - 45, 62, 10, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(10);
    doc.setFont("helvetica", "bold");
    doc.text(scanData.risk_score.toString(), pageWidth - 45, 66, { align: 'center' });
    doc.setFontSize(8);
    doc.setTextColor(...colors.lightText);
    doc.text("RISK SCORE", pageWidth - 32, 65);

    // Executive Summary
    let yPos = 90;
    doc.setFontSize(16);
    doc.setTextColor(...colors.primary);
    doc.text("1. Executive Summary", 20, yPos);
    yPos += 10;

    doc.setFontSize(11);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(...colors.text);

    // Safety check for AI Analysis
    const summaryText = (scanData.ai_analysis && scanData.ai_analysis.summary)
        ? scanData.ai_analysis.summary
        : "No AI summary available for this scan.";

    const summaryLines = doc.splitTextToSize(summaryText, pageWidth - 40);
    doc.text(summaryLines, 20, yPos);
    yPos += (summaryLines.length * 6) + 10;

    // Vulnerability Stats (Table)
    const findings = scanData.scan_details || [];
    const highCount = findings.filter(f => f.severity === 'High').length;
    const medCount = findings.filter(f => f.severity === 'Medium').length;
    const lowCount = findings.filter(f => f.severity === 'Low').length;
    const infoCount = findings.filter(f => f.severity === 'Info').length;

    // --- VISUALIZATION: PIE CHART ---
    const drawPieChart = (startY) => {
        doc.setFontSize(14);
        doc.setTextColor(...colors.primary);
        doc.text("Vulnerability Distribution", 20, startY);

        const chartY = startY + 35;
        const chartX = 60; // Center X
        const radius = 25;

        const total = highCount + medCount + lowCount + infoCount;
        if (total === 0) {
            doc.setFontSize(10);
            doc.setTextColor(...colors.lightText);
            doc.text("No vulnerabilities found to visualize.", 20, startY + 20);
            return startY + 40;
        }

        let startAngle = 0;

        const data = [
            { label: 'High', count: highCount, color: colors.high },
            { label: 'Medium', count: medCount, color: colors.medium },
            { label: 'Low', count: lowCount, color: colors.low },
            { label: 'Info', count: infoCount, color: colors.accent }
        ];

        // Helper to draw a sector using polygon approximation (more robust for jsPDF)
        data.forEach(slice => {
            if (slice.count === 0) return;

            const sliceAngle = (360 * slice.count) / total;
            const endAngle = startAngle + sliceAngle;

            // Create a polygon for the slice
            // Center point
            const points = [];
            points.push([chartX, chartY]);

            // Calculate points along the arc
            const step = 2; // Every 2 degrees for smoothness
            for (let a = startAngle; a <= endAngle; a += step) {
                const rad = (a * Math.PI) / 180;
                points.push([
                    chartX + radius * Math.cos(rad),
                    chartY + radius * Math.sin(rad)
                ]);
            }
            // Ensure end point is added
            const endRad = (endAngle * Math.PI) / 180;
            points.push([
                chartX + radius * Math.cos(endRad),
                chartY + radius * Math.sin(endRad)
            ]);

            // Draw filled polygon
            doc.setFillColor(...slice.color);

            for (let i = 1; i < points.length - 1; i++) {
                doc.triangle(
                    points[0][0], points[0][1], // Center
                    points[i][0], points[i][1], // Arc point 1
                    points[i + 1][0], points[i + 1][1], // Arc point 2
                    'F'
                );
            }

            startAngle += sliceAngle;
        });

        // Draw Legend
        let legendY = startY + 15;
        data.forEach(slice => {
            if (slice.count === 0) return;
            doc.setFillColor(...slice.color);
            doc.rect(110, legendY, 4, 4, 'F');
            doc.setFontSize(10);
            doc.setTextColor(...colors.text);
            doc.text(`${slice.label}: ${slice.count} (${Math.round((slice.count / total) * 100)}%)`, 116, legendY + 3);
            legendY += 8;
        });

        // donut hole (optional, makes it look modern)
        doc.setFillColor(255, 255, 255);
        doc.circle(chartX, chartY, radius * 0.5, 'F');

        doc.setFontSize(12);
        doc.setTextColor(...colors.primary);
        doc.setFont("helvetica", "bold");
        doc.text(total.toString(), chartX, chartY + 1, { align: 'center', baseline: 'middle' });
        doc.setFontSize(7);
        doc.text("TOTAL", chartX, chartY + 5, { align: 'center', baseline: 'middle' });

        return chartY + radius + 20;
    };

    // Draw pie chart
    yPos = drawPieChart(yPos);

    autoTable(doc, {
        startY: yPos,
        head: [['Severity', 'Count', 'Risk Level']],
        body: [
            ['High', highCount, 'Critical - Immediate Action'],
            ['Medium', medCount, 'Significant - Priority Fix'],
            ['Low', lowCount, 'Minor - Schedule Fix'],
            ['Info', infoCount, 'Informational']
        ],
        theme: 'striped',
        headStyles: { fillColor: colors.primary },
        styles: { fontSize: 10, cellPadding: 4 },
        columnStyles: { 0: { fontStyle: 'bold' } }
    });

    yPos = doc.lastAutoTable.finalY + 20;

    // --- DETAILED FINDINGS ---
    addFooter(doc.internal.getNumberOfPages());
    doc.addPage();
    addHeader();
    yPos = 30;

    doc.setFontSize(16);
    doc.setTextColor(...colors.primary);
    doc.text("2. Technical Findings", 20, yPos);
    yPos += 10;

    if (findings.length === 0) {
        doc.setFontSize(12);
        doc.setTextColor(...colors.lightText);
        doc.text("No vulnerabilities or issues detected.", 20, yPos + 10);
    } else {
        findings.forEach((finding, index) => {
            // Check page break
            if (yPos > pageHeight - 40) {
                addFooter(doc.internal.getNumberOfPages());
                doc.addPage();
                addHeader();
                yPos = 30;
            }

            // Finding Header
            const sevColor = finding.severity === 'High' ? colors.high : finding.severity === 'Medium' ? colors.medium : finding.severity === 'Low' ? colors.low : colors.accent;
            doc.setFillColor(...sevColor);
            doc.rect(20, yPos, 4, 18, 'F'); // Colored strip

            doc.setFontSize(12);
            doc.setTextColor(...colors.primary);
            doc.setFont("helvetica", "bold");
            doc.text(`${index + 1}. ${finding.vulnerability || 'Unnamed Issue'}`, 28, yPos + 6);

            // Meta Data Row
            doc.setFontSize(9);
            doc.setTextColor(...colors.lightText);
            doc.setFont("helvetica", "normal");
            let metaText = `Severity: ${finding.severity || 'Unknown'}   |   Type: ${finding.risk_type || 'General'}   |   CWE: ${finding.cwe_id || 'N/A'}`;
            if (finding.cvss_score) metaText += `   |   CVSS: ${finding.cvss_score}`;
            doc.text(metaText, 28, yPos + 14);

            yPos += 22;

            // Description
            doc.setFontSize(10);
            doc.setTextColor(...colors.text);
            doc.text("Description:", 25, yPos);
            const desc = finding.description || "No description provided.";
            const descLines = doc.splitTextToSize(desc, pageWidth - 45);
            doc.text(descLines, 25, yPos + 5);
            yPos += (descLines.length * 5) + 8;

            // Spacer
            yPos += 5;
        });
    }

    // --- RECOMMENDATIONS ---
    addFooter(doc.internal.getNumberOfPages());
    doc.addPage();
    addHeader();
    yPos = 30;

    doc.setFontSize(16);
    doc.setTextColor(...colors.primary);
    doc.text("3. Strategic Recommendations", 20, yPos);
    yPos += 10;

    const recs = (scanData.ai_analysis && scanData.ai_analysis.recommendations)
        ? scanData.ai_analysis.recommendations
        : [];

    if (recs.length === 0) {
        doc.setFontSize(12);
        doc.setTextColor(...colors.lightText);
        doc.text("No specific recommendations generated.", 20, yPos + 10);
    } else {
        recs.forEach((rec) => {
            // Check page break for recs
            if (yPos > pageHeight - 30) {
                addFooter(doc.internal.getNumberOfPages());
                doc.addPage();
                addHeader();
                yPos = 30;
            }

            doc.setFillColor(...colors.low);
            doc.circle(23, yPos - 1, 1.5, 'F'); // Bullet point

            doc.setFontSize(10);
            doc.setTextColor(...colors.text);
            const recLines = doc.splitTextToSize(rec, pageWidth - 35);
            doc.text(recLines, 28, yPos);
            yPos += (recLines.length * 5) + 5;
        });
    }

    // --- FOOTER FOR LAST PAGE ---
    addFooter(doc.internal.getNumberOfPages());

    // Save
    const safeUrl = (scanData.url || "report").replace(/[^a-z0-9]/gi, '_').substring(0, 20);
    doc.save(`CyberShield_Report_${safeUrl}_${new Date().toISOString().slice(0, 10)}.pdf`);
};
